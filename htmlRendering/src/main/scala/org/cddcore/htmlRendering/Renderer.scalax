package org.cddcore.reporting

import java.text.MessageFormat

import scala.language.implicitConversions
import org.antlr.stringtemplate.AttributeRenderer
import org.antlr.stringtemplate.StringTemplate
import org.cddcore.engine._
import org.cddcore.utilities._
import java.io.File
import javax.rmi.CORBA.GetORBPropertiesFileAction
import org.cddcore.htmlRendering.Report
import org.cddcore.htmlRendering.ReportableWrapper
import ReportableHelper._
import StartChildEndType._

object ReportWalker {
  def childWalker = new ChildReportWalker
  def engineConclusionWalker = new EngineConclusionWalker
  def documentThenEngineWalker = new DocumentThenEngineWalker
  def traceItemWalker = new TraceItemWalker
}
trait ReportWalker {
  import Reportable._
  /**
   * The head item in the initial path is 'walked down' and as more reportables are found start/end or child are called
   *  The route taken by by the ReportFolder may vary. For example it may walk down the engine/scenario/usecase route, or it may do engine/decision/conclusion... etc
   */
  def foldWithPath[Acc](initialPath: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc,
    childFn: (Acc, List[Reportable]) => Acc,
    endFn: (Acc, List[Reportable]) => Acc): Acc

  protected def walkChildren[Acc](holder: NestedHolder[Reportable], path: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc, childFn: (Acc, List[Reportable]) => Acc, endFn: (Acc, List[Reportable]) => Acc) =
    walkInList(holder, path, holder.nodes, initial, startFn, childFn, endFn)

  protected def walkInList[Acc](holder: NestedHolder[Reportable], path: List[Reportable], list: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc, childFn: (Acc, List[Reportable]) => Acc, endFn: (Acc, List[Reportable]) => Acc) = {
    var acc = startFn(initial, path)
    for (c <- list)
      acc = foldWithPath(c :: path, acc, startFn, childFn, endFn)
    acc = endFn(acc, path)
    acc
  }
}

class TraceItemWalker extends ReportWalker {
  import Reportable._
  type TI = TraceItem[Engine[_, _, _, _], Any, Any, Any]
  def foldWithPath[Acc](path: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc,
    childFn: (Acc, List[Reportable]) => Acc,
    endFn: (Acc, List[Reportable]) => Acc): Acc = {
    val head = path.head
    head match {
      case traceItem: TI => {
        val afterStart = startFn(initial, path)
        val afterEngine = childFn(afterStart, traceItem.main :: path)
        val afterChildren = traceItem.children.foldLeft(afterEngine)((acc, i) => foldWithPath(i :: path, acc, startFn, childFn, endFn))
        endFn(afterChildren, path)
      }
      case holder: NestedHolder[Reportable] => walkChildren(holder, path, initial, startFn, childFn, endFn)
      case _ => childFn(initial, path)
    }
  }
}

class ChildReportWalker extends ReportWalker {
  import Reportable._
  def foldWithPath[Acc](path: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc,
    childFn: (Acc, List[Reportable]) => Acc,
    endFn: (Acc, List[Reportable]) => Acc): Acc = {
    val head = path.head
    head match {
      case holder: NestedHolder[Reportable] => walkChildren(holder, path, initial, startFn, childFn, endFn)
      case _ => childFn(initial, path)
    }
  }
}

class DocumentThenEngineWalker extends ReportWalker {

  def foldWithPath[Acc](path: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc, childFn: (Acc, List[Reportable]) => Acc, endFn: (Acc, List[Reportable]) => Acc): Acc = {
    val helper = new ReportableHelper(path.head.asInstanceOf[NestedHolder[Reportable] with Reportable])
    helper.documentsAndEngineStartChildEndPaths.foldLeft(initial)((acc, pathAndCse) => pathAndCse match {
      case (path, Start) => startFn(acc, path)
      case (path, Child) => childFn(acc, path)
      case (path, End) => endFn(acc, path)
    })
  } 
}

class EngineConclusionWalker extends ReportWalker {
  import Reportable._
  def foldWithPath[Acc](path: List[Reportable], initial: Acc,
    startFn: (Acc, List[Reportable]) => Acc,
    childFn: (Acc, List[Reportable]) => Acc,
    endFn: (Acc, List[Reportable]) => Acc): Acc = {
    val head = path.head
    head match {
      case engine: EngineBuiltFromTests[_] =>
        var acc = startFn(initial, path)
        engine.walkDecisionsAndConclusion(engine.root, (cd: ConclusionOrDecision) => cd match {
          case c: Conclusion => acc = childFn(acc, c :: path)
          case d: Decision => ;
        })
        acc = endFn(acc, path)
        acc
      case holder: NestedHolder[Reportable] => walkChildren(holder, path, initial, startFn, childFn, endFn)
      case _ => childFn(initial, path)
    }
  }

}

object ReportCreator {
  def unnamed = "<Unnamed>"

  def fileSystem(loggerDisplayProcessor: LoggerDisplayProcessor, r: NestedHolder[Reportable], title: String = null, live: Boolean = false, reportableToUrl: FileSystemReportableToUrl = new FileSystemReportableToUrl, optUrlMap: Option[UrlMap] = None): FileReportCreator =
    new FileReportCreator(loggerDisplayProcessor, r, title, live, reportableToUrl, optUrlMap)

}

class FileReportCreator(loggerDisplayProcessor: LoggerDisplayProcessor, r: NestedHolder[Reportable], title: String, live: Boolean = false, reportableToUrl: FileSystemReportableToUrl, optUrlMap: Option[UrlMap]) extends ReportCreator[FileSystemReportableToUrl](loggerDisplayProcessor, r, title, live, reportableToUrl, optUrlMap) {
  protected def print(path: List[Reportable], html: String) {
    val file = reportableToUrl.file(path)
    if (Engine.logging) println("Creating" + file)
    Files.printToFile(file)((p) => p.append(html))
  }
  protected def makeReport = (path: List[Reportable]) =>
    htmlFor(path) match {
      case Some(html) => print(path, html)
      case _ => ;
    }
  def create = {
    val directory = reportableToUrl.directory(List(r))

    Files.delete(directory)
    report.walkWithPath(makeReport)
    val documents = Reportable.documentsIn(report)
    documents.map(List(_, report)).foreach(makeReport)
  }
}

class ReportCreator[RtoUrl <: ReportableToUrl](loggerDisplayProcessor: LoggerDisplayProcessor, r: NestedHolder[Reportable], title: String, val live: Boolean = false, val reportableToUrl: RtoUrl, optUrlMap: Option[UrlMap] = None) {
  import Reportable._
  import PathUtils._
  import Renderer._
  val report = r match {
    case r: Report => r
    case r: Requirement =>
      Report(if (title == null) r.titleOrDescription("Unnamed") else title, r)
    case null => throw new NullPointerException("Is this because your item is a val and not a lazy val?")
    case _ => throw new IllegalArgumentException(r.toString)
  }
  val urlMap = optUrlMap.getOrElse(reportableToUrl.makeUrlMap(report))
  val rootUrlObject = r match {
    case r: Report => r.nodes match {
      case h :: Nil => h;
      case _ => throw new IllegalArgumentException("Currently can only make a report for one thing")
    }
    case _ => r
  }
  val rootUrl = reportableToUrl.url(List(rootUrlObject, report))
  if (Engine.logging) println("RootUrl = " + rootUrl)
  def htmlFor(path: List[Reportable]) = {
    val pathHead = path.head
    if (!urlMap.contains(pathHead))
      throw new IllegalStateException
    val optHtml = pathHead match {
      //        case r: Report => Some(HtmlRenderer.reportHtml(rootUrl).render(reportableToUrl, urlMap, r))
      case d: Document => {
        val strategy = new ByReferenceDocumentPrinterStrategy(Some(d), new SimpleKeyStrategy)
        val documentDetails = strategy.makeReportOfJustDocuments(r)
        val report = Report(Some(d.titleString), documentDetails)
        val renderer = HtmlRenderer(loggerDisplayProcessor, true).documentsHtml(rootUrl)
        val html = renderer.render(reportableToUrl, urlMap, report)
        Some(html)
      }
      case p: Project =>
        Some(HtmlRenderer(loggerDisplayProcessor, live).projectHtml(rootUrl).render(reportableToUrl, urlMap, Report("Project: " + p.titleOrDescription(ReportCreator.unnamed), p)))
      case e: Engine => Some(HtmlRenderer(loggerDisplayProcessor, live).engineHtml(rootUrl).render(reportableToUrl, urlMap, Report("Engine: " + e.titleOrDescription(ReportCreator.unnamed), findEngine(path))))
      case u: UseCase => Some(HtmlRenderer(loggerDisplayProcessor, live).usecaseHtml(rootUrl, restrict = path.toSet ++ u.children).render(reportableToUrl, urlMap, Report("Usecase: " + u.titleOrDescription(ReportCreator.unnamed), findEngine(path))))
      case t: Test =>
        val conclusion = PathUtils.findEngineWithTests(path).findConclusionFor(t.params)
        Some(HtmlRenderer(loggerDisplayProcessor, live).scenarioHtml(rootUrl, conclusion, t, path.toSet).render(reportableToUrl, urlMap, Report("Scenario: " + t.titleString, findEngine(path))))
      case _ => None
    }
    optHtml
  }

}
trait ReportableToUrl {
  import Reportable._
  protected var reqId = 0
  protected var cache = Map[Reportable, String]()
  protected var seen = Set[String]()

  protected def findAndAddToCacheIfNeed(r: Reportable): String = {
    val existing = cache.get(r)
    existing match {
      case Some(s) => s;
      case _ => {
        def makeNewName: String = {
          reqId += 1; val default = templateName(r) + reqId;
          val result = Strings.urlClean(r match {
            //            case report: Report => { val result = report.title.getOrElse(default); if (result.length > 120) default else result }
            case project: Project => { val result = project.title.getOrElse(default); if (result.length > 120) default else result }
            case req: Requirement => { val result = req.titleOrDescription(default); if (result.length > 40) default else result }
            case _ => default;
          }).replace(" ", "_")
          if (seen.contains(result)) default else result
        }
        var result: String = null
        do {
          result = makeNewName
        } while (seen.contains(result))
        cache += (r -> result)
        seen += result
        result
      }
    }
  }

  /** Will return a human readable name for the reportable. Will allways return the same name for the reportable */
  def apply(r: Reportable): String = {
    r match {
      case r: ReportableWrapper => findAndAddToCacheIfNeed(r.delegate.getOrElse(r))
      case _ => findAndAddToCacheIfNeed(r)
    }
  }

  /** Will return a human readable name for each reportable in the reversed list. Typically this is used to make a path */
  def apply(path: List[Reportable], separator: String = "/"): String = path.reverse.map(apply(_)).mkString(separator)

  /** We give each reportable a unique id, so that if it occurs once in an html document, we can reference it by id */
  def urlId(r: Reportable, suffix: Option[String] = None): String = templateName(r) + "_" + apply(r) + suffix.collect { case s => "_" + s }.getOrElse("")

  def url(path: List[Reportable]): Option[String]

  protected def add = (urlMap: UrlMap, path: List[Reportable]) => {
    val u = url(path);
    if (u.isDefined) urlMap + (path -> u.get) else urlMap
  }

  def makeUrlMap(r: NestedHolder[Reportable]): UrlMap = {
    val fromBasicReportables = r.foldWithPath(UrlMap(Map(), Map()), add)
    documentsIn(r).map(List(_, r)).foldLeft(fromBasicReportables)(add)
  }

  def makeUrlMapWithDecisionsAndConclusions(r: NestedHolder[Reportable]): UrlMap =
    r.foldWithPath(UrlMap(Map(), Map()), ((acc: UrlMap, path) => {
      def addToMap(acc: UrlMap, path: List[Reportable]) = {
        val u = url(path);
        val withU = if (u.isDefined) acc + (path -> u.get) else acc
        withU
      }
      val withU = addToMap(acc, path)
      path.head match {
        case e: EngineBuiltFromTests[_] => e.fold(withU, new DecisionTreeFolder[UrlMap] {
          def apply(acc: UrlMap, c: Conclusion) = addToMap(acc, c :: path)
          def apply(acc: UrlMap, d: Decision) = addToMap(acc, d :: path)
        })
        case _ => withU
      }
    }))
}

class FileSystemReportableToUrl(val dir: File = CddRunner.directory) extends ReportableToUrl {
  import Reportable._
  def directory(path: List[Reportable]) = new File(dir, apply(path, "\\"))
  def file(path: List[Reportable]) = new File(dir, apply(path, "\\") + "." + templateName(path) + ".html")
  def url(path: List[Reportable]) = Some("file:///" + file(path).getAbsolutePath())
}

class SimpleReportableToUrl extends ReportableToUrl {
  def url(path: List[Reportable]) = Some("/" + apply(path) + "." + Reportable.templateName(path) + ".html")
}
class NoReportableToUrl extends ReportableToUrl {
  import Reportable._
  def dir: File = CddRunner.directory
  def url(path: List[Reportable]) = None
  override def hashCode = 0
  override def equals(other: Any) = other != null && other.isInstanceOf[NoReportableToUrl]
}
case class ReportableRenderer(loggerDisplayProcessor: LoggerDisplayProcessor, restrict: Set[Reportable], configurers: List[RenderAttributeConfigurer] = List(), templates: Map[String, Renderer] = Map(), walker: ReportWalker, rootUrl: Option[String]) {
  import Reportable._
  import Renderer._

  def render(reportableToUrl: ReportableToUrl, urlMap: UrlMap, holder: NestedHolder[Reportable]): String = {
    if (!restrict.isEmpty && !restrict.contains(holder)) {
      val newRenderer = copy(restrict = restrict + holder)
      return newRenderer.render(reportableToUrl, urlMap, holder)
    }

    def addIt(postFix: String) = (acc: String, path: List[Reportable]) => {
      val t = templateName(path) + postFix;
      val result = render(reportableToUrl, loggerDisplayProcessor, urlMap, path, t)
      acc + result
    }
    val result = walker.foldWithPath(List(holder), "", addIt("_start"), addIt(""), addIt("_end"))
    result
  }

  def configureAttribute(rc: RenderAttributeConfigurer*) = copy(configurers = rc.toList ::: configurers)

  def configureReportable(templateName: String, renderer: Renderer): ReportableRenderer = copy(templates = templates + (templateName -> renderer))

  def configureReportable(templateNameAndTemplates: StringRenderer*): ReportableRenderer =
    templateNameAndTemplates.foldLeft(this)((renderer, tAndN) => renderer.configureReportable(tAndN._1, tAndN._2))

  def configureNestedHolder[Reportable](templateName: String, rendererStart: Renderer, rendererEnd: Renderer): ReportableRenderer =
    copy(templates = (templates +
      (templateName + "_start" -> rendererStart) +
      (templateName + "_end" -> rendererEnd)))

  def configureNestedHolder[Reportable](templateNameAndTemplates: StringRendererRenderer*): ReportableRenderer =
    templateNameAndTemplates.foldLeft(this)((renderer, tAndN) => renderer.configureNestedHolder[Reportable](tAndN._1, tAndN._2, tAndN._3))

  protected def render(reportableToUrl: ReportableToUrl, loggerDisplayProcessor: LoggerDisplayProcessor, urlMap: UrlMap, path: List[Reportable], templateName: String): String = {
    if (!restrict.isEmpty && !restrict.contains(path.head))
      return ""
    val optRenderer = templates.get(templateName)
    val result = optRenderer match {
      case Some(renderer: StringTemplateRenderer) =>
        renderer.clear
        for (c <- configurers)
          c.update(reportableToUrl, loggerDisplayProcessor, urlMap, path, renderer.stringTemplate, rootUrl)
        renderer.render(reportableToUrl, urlMap, path)
      case Some(renderer: Renderer) =>
        renderer.clear
        renderer.render(reportableToUrl, urlMap, path)
      case None => ""
    }
    result
  }
}

case class RendererContext[R <: Reportable](reportableToUrl: ReportableToUrl, loggerDisplayProcessor: LoggerDisplayProcessor, urlMap: UrlMap, path: List[Reportable], r: R, stringTemplate: StringTemplate, rootUrl: Option[String])

object Renderer {
  import Reportable._
  type StringRenderer = Tuple2[String, Renderer]
  type StringRendererRenderer = Tuple3[String, Renderer, Renderer]
  implicit def apply(s: String) = StringTemplateRenderer(s)

  val engineFromTestsKey = "EngineFromTests"
  val engineChildKey = "EngineChild"
  val engineWithChildrenKey = "EngineWithChildren"
  val mergedReportableKey = "Merged"

  val renderer = new ValueForRenderer
  val refRenderer = new ReferenceRenderer
  private val dateFormat: String = "HH:mm EEE MMM d yyyy"
  val dateFormatter = DateTimeFormat.forPattern(dateFormat);
  def base(loggerDisplayProcessor: LoggerDisplayProcessor, rootUrl: Option[String], restrict: Set[Reportable], walker: ReportWalker = ReportWalker.childWalker): ReportableRenderer =
    new ReportableRenderer(loggerDisplayProcessor, restrict, walker = walker, rootUrl = rootUrl)
  def apply(loggerDisplayProcessor: LoggerDisplayProcessor, rootUrl: Option[String], restrict: Set[Reportable], live: Boolean, walker: ReportWalker = ReportWalker.childWalker) =
    base(loggerDisplayProcessor, rootUrl, restrict, walker).configureAttribute(basic(live), engineConfig, reportConfig, testConfig)

  protected def basic(live: Boolean) = RenderAttributeConfigurer((rendererContext) => {
    import rendererContext._
    val r = path.head
    stringTemplate.setAttribute("rootUrl", rootUrl.getOrElse(null))
    stringTemplate.setAttribute("indent", Integer.toString(path.size))
    if (live)
      stringTemplate.setAttribute("live", Integer.toString(path.size))
    def addFromRequirement(req: Requirement) {
      val r = Reportable.unwrap(req)
      stringTemplate.setAttribute("description", r.description.collect { case d => ValueForRender(d, loggerDisplayProcessor) }.getOrElse(null))
      stringTemplate.setAttribute("title", ValueForRender(r.titleString, loggerDisplayProcessor))
      for (ref <- r.references)
        stringTemplate.setAttribute("references", ref)
      if (urlMap.contains(r)) {
        val url = urlMap(r)
        stringTemplate.setAttribute("url", url)
        stringTemplate.setAttribute("urlId", reportableToUrl.urlId(path.head))
      }
    }
    r match {
      case r: MergedReportable =>
        stringTemplate.setAttribute("key", ValueForRender(r.key, loggerDisplayProcessor))
      case t: MergedTitle =>
        stringTemplate.setAttribute("title", ValueForRender(t.title.getOrElse(""), loggerDisplayProcessor))
      case d: MergedDescription =>
        stringTemplate.setAttribute("description", ValueForRender(d.description.getOrElse(""), loggerDisplayProcessor))
      case m: MergedShortDescription =>
        stringTemplate.setAttribute("title", ValueForRender(m.name, loggerDisplayProcessor))
      case re: RequirementAndEngine =>
        addFromRequirement(re.reportable)
        val engineName = re.engine.collect { case e: Engine => e.titleOrDescription("") }.getOrElse("")
        stringTemplate.setAttribute("engineName", ValueForRender(engineName, loggerDisplayProcessor))
        stringTemplate.setAttribute("engineSummary", ValueForRender(Strings.firstCharacters(engineName), loggerDisplayProcessor))
      case req: Requirement => addFromRequirement(req)

      case _ =>
    }
    r match {
      case holder: NestedHolder[Reportable] =>
        stringTemplate.setAttribute("childrenCount", holder.children.size)
      case _ => ;
    }
  })

  protected def engineConfig = RenderAttributeConfigurer[Engine](Set(engineFromTestsKey), (rc) => { import rc._; stringTemplate.setAttribute("decisionTreeNodes", r.decisionTreeNodes) })

  def traceItemConfig = RenderAttributeConfigurer[TraceItem](Set("TraceItem"), (rc: RendererContext[TraceItem]) => {
    import rc._ //    addParams(stringTemplate, "params", loggerDisplayProcessor, r.params)
    //    stringTemplate.setAttribute("title", r.engine.titleString)
    //    stringTemplate.setAttribute("result", loggerDisplayProcessor(r.result))
    ;
  })
  def traceItemEngineConfig = RenderAttributeConfigurer[Engine](Set(engineChildKey, engineWithChildrenKey, engineFromTestsKey), (rc: RendererContext[Engine]) => {
    import rc._
    val traceItem = PathUtils.findTraceItem(path)
    addParams(stringTemplate, "params", loggerDisplayProcessor, traceItem.params)
    r match {
      case e: EngineBuiltFromTests[_] =>
        stringTemplate.setAttribute("decisionTree", e.toStringWith(
          new HtmlWithTestIfThenPrinter(traceItem.params, traceItem.conclusion, None, reportableToUrl, urlMap)))
      case _ =>
    }
    //    stringTemplate.setAttribute("title", r.titleString)

    stringTemplate.setAttribute("result", ValueForRender(traceItem.result, loggerDisplayProcessor))
  })

  def decisionTreeConfig(params: Option[List[Any]], conclusion: Option[Conclusion], test: Option[Test]) =
    {
      val fn = (rc: RendererContext[EngineBuiltFromTests[_]]) => {
        import rc._
        stringTemplate.setAttribute("decisionTree", r.toStringWith(params match {
          case Some(p) => new HtmlWithTestIfThenPrinter(p, conclusion, test, reportableToUrl, urlMap)
          case _ => new HtmlIfThenPrinter(reportableToUrl, urlMap)
        }))
      }
      RenderAttributeConfigurer[EngineBuiltFromTests[_]](Set(engineChildKey, engineFromTestsKey), fn)
    }
  def documentConfig =
    RenderAttributeConfigurer[Document](Set("Document"), (rc: RendererContext[Document]) => {
      import rc._
      if (r.url.isDefined)
        stringTemplate.setAttribute("documentUrl", r.url.get)
    })
  def documentHolderConfig =
    RenderAttributeConfigurer[DocumentHolder](Set("DocumentHolder"), (rc: RendererContext[DocumentHolder]) => {
      import rc._
      if (r.children.size == 0)
        stringTemplate.setAttribute("noChildren", "true")
    })

  def setMergedReportable: RenderAttributeConfigurer = RenderAttributeConfigurer[MergedReportable](Set(mergedReportableKey), (rc) => {
    import rc._
    val htmlRenderer = new HtmlRenderer(rc.loggerDisplayProcessor, false)
    val renderer = htmlRenderer.mergedReportableTitle(rootUrl)
    val html = r.titles.foldLeft("")((acc, mt) =>
      acc + renderer.render(reportableToUrl, urlMap, mt))
    stringTemplate.setAttribute("mergedReportable", html)
    if (r.titles.length != 1)
      stringTemplate.setAttribute("multipleMergedValuesFlag", "true")
  })

  def setAttribute(templateName: String, attributeName: String, value: Any) =
    RenderAttributeConfigurer[EngineBuiltFromTests[_]](Set(templateName), (rc) => { import rc._; stringTemplate.setAttribute(attributeName, value) })

  protected def reportConfig = RenderAttributeConfigurer[Report](Set("Report"), (rc) => {
    import rc._
    stringTemplate.setAttribute("reportDate", dateFormatter.print(System.currentTimeMillis()))
  })

  def addParams(st: StringTemplate, attributeName: String, loggerDisplayProcessor: LoggerDisplayProcessor, params: List[Any]) {
    for (p <- params)
      p match {
        case h: HtmlDisplay =>
          st.setAttribute(attributeName, ValueForRender(h, loggerDisplayProcessor))
        case _ =>
          st.setAttribute(attributeName, ValueForRender(p, loggerDisplayProcessor))
      }
  }

  protected def testConfig = RenderAttributeConfigurer[Test](Set("Scenario"), (rendererContext) => {
    import rendererContext._
    import r._
    //    stringTemplate.setAttribute("title", ValueForRender(titleString))
    stringTemplate.setAttribute("code", ValueForRender(optCode.collect { case c => c.pretty } getOrElse (null), loggerDisplayProcessor))
    stringTemplate.setAttribute("expected", ValueForRender(expected.getOrElse(""), loggerDisplayProcessor))
    stringTemplate.setAttribute("paramCount", params.size)
    stringTemplate.setAttribute("because", ValueForRender(r.because.collect { case c => c.pretty } getOrElse (null), loggerDisplayProcessor))
    addParams(stringTemplate, "params", loggerDisplayProcessor, params)
  })
}

trait Renderer {
  def clear;

  def render(reportableToUrl: ReportableToUrl, urlMap: UrlMap, path: List[Reportable]): String
}

object RenderAttributeConfigurer {
  import Reportable._
  def apply(fn: (RendererContext[_]) => Unit) = BaseRenderAttributeConfigurer(fn)
  def apply[R <: Reportable](templateNames: Set[String], fn: (RendererContext[R]) => Unit) = TypedRenderAttributeConfigurer[R](templateNames, fn)

  case class BaseRenderAttributeConfigurer(val fn: (RendererContext[_]) => Unit) extends RenderAttributeConfigurer {
    import Reportable._
    def update(reportableToUrl: ReportableToUrl, loggerDisplayProcessor: LoggerDisplayProcessor, urlMap: UrlMap, path: List[Reportable], template: StringTemplate, rootUrl: Option[String]) {
      fn(RendererContext[Reportable](reportableToUrl, loggerDisplayProcessor, urlMap, path, path.head, template, rootUrl))
    }
  }

  case class TypedRenderAttributeConfigurer[R <: Reportable](val templateNames: Set[String], setAttributes: (RendererContext[R]) => Unit) extends RenderAttributeConfigurer {
    import Reportable._
    def update(reportableToUrl: ReportableToUrl, loggerDisplayProcessor: LoggerDisplayProcessor, urlMap: UrlMap, path: List[Reportable], template: StringTemplate, rootUrl: Option[String]) {
      val r = Reportable.unwrap(path.head)
      if (templateNames.contains(Reportable.templateName(r)))
        setAttributes(RendererContext[R](reportableToUrl, loggerDisplayProcessor, urlMap, path, r.asInstanceOf[R], template, rootUrl))
    }
  }
}

trait RenderAttributeConfigurer {
  import Reportable._
  def update(reportableToUrl: ReportableToUrl, loggerDisplayProcessor: LoggerDisplayProcessor, urlMap: UrlMap, path: List[Reportable], template: StringTemplate, rootUrl: Option[String])
}
case class StringTemplateRenderer(template: String) extends Renderer {
  import Renderer._
  import Reportable._
  val stringTemplate = new StringTemplate(template)
  stringTemplate.registerRenderer(classOf[ValueForRender], renderer)
  stringTemplate.registerRenderer(classOf[Reference], refRenderer)

  def clear = stringTemplate.reset()

  def render(reportableToUrl: ReportableToUrl, urlMap: UrlMap, path: List[Reportable]): String = {
    val result = stringTemplate.toString
    result
  }
}

class ValueForRender(val value: Any, val ldp: LoggerDisplayProcessor) {
  override def toString = if (value == null) "" else ldp(value)
}

object ValueForRender {
  def apply(o: Any, ldp: LoggerDisplayProcessor) = if (o == null) null else new ValueForRender(o, ldp)
}

class ValueForRenderer extends AttributeRenderer {
  def toString(o: Object): String = toString(o, "")
  def toString(o: Object, format: String): String = {
    o match {
      case v: ValueForRender => v.value match {
        case null => null
        case x: HtmlDisplay => x.htmlDisplay
        case _ => Strings.htmlEscape(v.ldp(o))
      }
    }
  }

}
class ReferenceRenderer extends AttributeRenderer {
  def toString(o: Object): String = toString(o, "")
  def toString(o: Object, format: String): String = {
    val ref = o.asInstanceOf[Reference]
    val document = ref.document
    document match {
      case Some(d) => {
        val nameAndLink = Strings.htmlEscape(d.titleString)
        val link = d.url match {
          case Some(url) => s"<a href='$url'><img src='${HtmlRenderer.referenceIconUrl}' /></a>"
          case _ => ""
        }
        nameAndLink + link
      }
      case None => ref.ref
    }
  }

}

object HtmlRenderer {
  import Reportable._
  import Renderer._

  def apply(loggerDisplayProcessor: LoggerDisplayProcessor, live: Boolean = false) = new HtmlRenderer(loggerDisplayProcessor, live)
  protected val title = "$title$"
  protected val description = "$if(description)$$description$$endif$"
  protected val date = "$if(reportDate)$<hr /><div class='dateTitle'>$reportDate$</div><hr /><div>$reportDate$</div>$endif$"
  def titleAndDescription(clazz: String, titlePattern: String, iconPrefix: String = "") =
    s"<div class='$clazz'>" + a(iconPrefix + MessageFormat.format(titlePattern, title)) + "<br />" + description + "</div>"
  def a(body: String) = "$if(url)$<a $if(urlId)$id='$urlId$' $endif$href='$url$'>$endif$" + body + "$if(url)$</a>$endif$"
  def a(body: String, title: String) = "$if(url)$<a $if(urlId)$id='$urlId$' $endif$href='$url$' title='" + title + "'>$endif$" + body + "$if(url)$</a>$endif$"
  def aForLive = "$if(url)$<a id='$url$/live' href='$url$/live'>$endif$Live$if(url)$</a>$endif$"

  protected def cddLogo = "<img src='http://img32.imageshack.us/img32/8151/xy9u.png'  alt='Report Home Page'/>"
  def referenceIconUrl = "http://imageshack.com/a/img850/2134/u5hr.png"
  protected def engineWithChildrenIcon = "<img src='http://i782.photobucket.com/albums/yy108/phil-rice/engineFold2_zpsb62930b9.png'  alt='engine with children icon'/>"
  protected def childEngineIcon = "<img src='http://i782.photobucket.com/albums/yy108/phil-rice/engineChild_zps3d29a414.png'  alt='child engine icon'/>"
  protected def engineWithTestsIcon = "<img src='http://i782.photobucket.com/albums/yy108/phil-rice/engine_zps9a86cef4.png'  alt='engine with tests icon'/>"
  protected def usecaseIcon = "<img src='http://i782.photobucket.com/albums/yy108/phil-rice/useCase_zps23a7250c.png'  alt='usecase icon'/>"

  val expectedRow = "<tr><td class='title'>Expected</td><td class='value'>$if(expected)$$expected$$endif$</td></tr>"
  protected val codeRow = "$if(code)$<tr><td class='title'>Code</td><td class='value'>$code$</td></tr>$endif$"
  protected val becauseRow = "$if(because)$<tr><td class='title'>Because</td><td class='value'>$because$</td></tr>$endif$"
  val paramsRow = "<tr><td class='title'>Parameter</td><td class='value'>$params: {p|$p$}; separator=\"<hr /> \"$</td></tr>"
  def engineRow(icon: String): String = "<tr><td class='engineTitle'>Engine</td><td class='engineValue'>" + icon + "$title$</td></tr>"
  val resultsRow = "<tr><td class='title'>Result</td><td class='value'>$result$</td></tr>"
  //  protected val useCasesRow = "$if(childrenCount)$<tr><td class='title'>Usecases</td><td class='value'>$childrenCount$</td></tr>$endif$"
  protected val scenariosRow = "$if(childrenCount)$<tr><td class='title'>Scenarios</td><td class='value'>$childrenCount$</td></tr>$endif$"
  protected val refsRow = "$if(references)$<tr><td class='title'>References</td><td class='value'>$references: {r|$r$}; separator=\", \"$</td></tr>$endif$"

  lazy val css = Files.getFromClassPath(getClass, "cdd.css")
  val reportTemplate: StringRendererRenderer = ("Report", {
    "<!DOCTYPE html><html><head><title>CDD Report: $title$</title><style>" +
      css + "\n</style></head>\n" +
      "<body>" +
      "<div class='report'>" +
      "<div class='topLine'>" +
      "<div class='cddLogo'>$if(rootUrl)$<a id='cddLogo' href='$rootUrl$'>$endif$" + cddLogo + "$if(rootUrl)$</a>$endif$</div>\n" +
      "<div class='cddBox'>" + Files.getFromClassPath(getClass, "OurAdvert.xml") + "</div>\n" +
      "<div class='reportTopBox'>\n" +
      "<div class='reportTitle'>Report name</div>\n" +
      "<div class='reportText'>" + title + " " + description + "</div>\n" +
      "<div class='reportTitle'>Report date</div>\n" +
      "<div class='reportDate'>$reportDate$</div>\n" +
      "</div><!--Report Top Box-->\n</div><!-- top Line -->\n"
  }, "</div><!-- report -->\n</body></html>")

  val projectTemplate: StringRendererRenderer =
    ("Project", "<div class='project'><div class='projectText'><b>Project: $title$</b> " + description + "</div>\n", "</div> <!-- Project -->\n")
  val documentHolderTemplate: StringRendererRenderer =
    ("DocumentHolder", "<div class='documentHolder'><h3>Documents</h3><ul>$if(noChildren)$No documents defined$endif$", "</ul></div><!-- documentHolder -->\n");
  val engineHolderTemplate: StringRendererRenderer =
    ("EngineHolder", "<div class='engineHolder'><h3>Engines</h3><ul>", "</ul></div><!-- engineHolder -->\n");
  def listItemTitle(postFix: String = "") = "<li>" + a("$title$", "$description$") + postFix + "</li>"
  val documentSummaryTemplate: StringRenderer =
    ("Document", listItemTitle("$if(documentUrl)$<a href='$documentUrl$'><img src='" + referenceIconUrl + "' /></a>$endif$"));
  val engineWithTestsSummaryTemplate: StringRenderer =
    (engineFromTestsKey, listItemTitle());
  val childEngineSummaryTemplate: StringRenderer =
    (engineChildKey, listItemTitle());
  val engineWithChildrenSummaryTemplate: StringRendererRenderer =
    (engineWithChildrenKey, "<li>" + a("$title$", "$description$") + "<ul>", "</ul></li>");

  val mergedTemplate: StringRendererRenderer =
    ("Merged", "<div class='merged'><b>$key$</b> $if(multipleMergedValuesFlag)$<div class='multipleTitles'>$endif$$mergedReportable$", "$if(multipleMergedValuesFlag)$</div>$endif$</div><!-- merged -->\n")

  val mergedTitleTemplate: StringRendererRenderer =
    ("MergedTitle", "<b>$title$</b>", "\n")

  val mergedDescriptionTemplate: StringRendererRenderer =
    //  ("MergedDescription", "", "$description$")
    ("MergedDescription", "", "<div class='mergedDescription'>$description$</div>\n")

  // So why is this an engine with tests icon? Well it turns out that this is displayed as part of a use case anyway, and the engine with tests followed by a summary of the name of the engine 'looks better' 
  val useCaseIconTemplate: StringRendererRenderer = ("UseCase", a(engineWithTestsIcon + "$engineSummary$", "$engineName$"), "")

  val requirementAndEngineTemplate: StringRendererRenderer =
    ("RequirementAndEngine", "<div class='requirementAndEngine'> $title$ ", "</div><!-- requirementAndEngine -->\n")

  val engineWithTestsTemplate: StringRendererRenderer =
    (engineFromTestsKey, "<div class='engineWithTests'>" +
      "<div class='engineSummary'>" + titleAndDescription("engineText", "Engine {0}", engineWithTestsIcon) + "$if(live)$" + aForLive + "$endif$" + table("engineTable", refsRow),

      "</div><!-- engineSummary -->" +
      "<div class='decisionTree'>\n$decisionTree$</div><!-- decisionTree -->\n" +
      "</div><!-- engine -->\n")
  val childEngineTemplate: StringRendererRenderer =
    (engineChildKey, "<div class='childEngine'>" +
      "<div class='engineSummary'>" + titleAndDescription("engineText", "Engine {0}", childEngineIcon) + "$if(live)$" + aForLive + "$endif$" + table("engineTable", refsRow),

      "</div><!-- engineSummary -->" +
      "<div class='decisionTree'>\n$decisionTree$</div><!-- decisionTree -->\n" +
      "</div><!-- engine -->\n")

  val engineWithChildEngineTemplate: StringRendererRenderer =
    (engineWithChildrenKey, "<div class='engineWithChildren'>" +
      "<div class='engineWithChildrenSummary'>" + titleAndDescription("engineText", "Engine {0}", engineWithChildrenIcon) + "$if(live)$" + aForLive + "$endif$" + table("engineTable", refsRow),

      "</div><!-- engineWithChildrenSummary -->" +
      "</div><!-- engine -->\n")

  val liveEngineTemplate: StringRendererRenderer =
    (engineFromTestsKey, "<div class='engine'>" +
      "<div class='engineSummary'>" + titleAndDescription("engineText", "Engine {0}") + table("engineTable", refsRow) + "$engineForm$",

      "</div><!-- engineSummary -->" +
      "<div class='decisionTree'>\n$decisionTree$</div><!-- decisionTree -->\n" +
      "</div><!-- engine -->\n")

  val liveEngineWithChildrenTemplate: StringRendererRenderer =
    (engineWithChildrenKey, "<div class='engine'>" +
      "<div class='engineSummary'>" + titleAndDescription("engineText", "Engine {0}") + table("engineTable", refsRow) + "Cannot yet execute live Engines with children",

      "</div><!-- engineSummary -->" +
      "<div class='decisionTree'>\n$decisionTree$</div><!-- decisionTree -->\n" +
      "</div><!-- engine -->\n")

  val useCaseTemplate: StringRendererRenderer =
    ("UseCase",
      "<div class='usecase'>" + "<h4>" + a(usecaseIcon + title) + "</h4>\n$if(description)$<p>$description$</p>$endif$" + "\n" + table("usecaseTable", refsRow) + "\n",
      "</div><!-- useCase -->\n")

  val useCaseWithScenariosSummarisedTemplate: StringRendererRenderer =
    ("UseCase",
      s"<div class='usecaseSummary'><h4>${a(usecaseIcon + title)}\n",
      "</h4>$if(description)$<p>$description$</p>$endif$" + "</div><!-- usecaseSummary -->\n")

  val scenarioTemplate: StringRenderer = ("Scenario", "<div class='scenario'>" + titleAndDescription("scenarioText", "Scenario: {0}") +
    table("scenarioTable",
      refsRow,
      paramsRow,
      expectedRow,
      codeRow,
      becauseRow) + "</div><!-- scenario -->\n")

  val scenarioSummaryTemplate: StringRenderer = ("Scenario", a("<img src='" + HtmlForIfThenPrinter.normalScenarioIcon + "' $if(title)$title='$title$'$endif$ />"))

  val traceItemTemplate: StringRendererRenderer =
    ("TraceItem",
      "<div class='traceItem'>\n",
      "</div> <!-- TraceItem -->\n")

  val traceItemEngineWithChildrenTemplate: StringRenderer =
    (engineWithChildrenKey, table("traceItemTable", engineRow(engineWithChildrenIcon), paramsRow, resultsRow))

  val traceItemEngineChildTemplate: StringRenderer =
    (engineChildKey,
      "<div class='traceItemEngine'>" + table("traceItemTable", engineRow(childEngineIcon), resultsRow) + "<div class='decisionTreeForTraceItem'>\n$decisionTree$</div><!-- decisionTree -->\n </div><!-- traceItemEngine -->\n")

  val traceItemEngineBuiltFromTestsTemplate: StringRenderer =
    (engineFromTestsKey,
      "<div class='traceItemEngine'>" + table("traceItemTable", engineRow(childEngineIcon), paramsRow, resultsRow) + "<div class='decisionTreeForTraceItem'>\n$decisionTree$</div><!-- decisionTree -->\n </div><!-- traceItemEngine -->\n")

  def table(clazz: String, rows: String*) = {
    val result = s"<table class='$clazz'>${rows.mkString("")}</table>"
    result
  }
}

class HtmlRenderer(loggerDisplayProcessor: LoggerDisplayProcessor, live: Boolean) {
  import HtmlRenderer._
  def projectHtml(rootUrl: Option[String], restrict: Set[Reportable] = Set()) =
    Renderer(loggerDisplayProcessor, rootUrl, restrict, live, walker = ReportWalker.documentThenEngineWalker).
      configureAttribute(Renderer.documentConfig, Renderer.documentHolderConfig).
      configureNestedHolder[Reportable](reportTemplate, documentHolderTemplate, engineHolderTemplate, engineWithChildrenSummaryTemplate).
      configureReportable(documentSummaryTemplate, engineWithTestsSummaryTemplate, childEngineSummaryTemplate)

  def engineHtml(rootUrl: Option[String], restrict: Set[Reportable] = Set()) = Renderer(loggerDisplayProcessor, rootUrl, restrict, live).
    configureAttribute(Renderer.decisionTreeConfig(None, None, None)).
    configureNestedHolder[Reportable](reportTemplate, projectTemplate, engineWithTestsTemplate, engineWithChildEngineTemplate, childEngineTemplate, useCaseWithScenariosSummarisedTemplate).
    configureReportable(scenarioSummaryTemplate)

  def liveEngineHtml(rootUrl: Option[String], params: Option[List[Any]], conclusion: Option[Conclusion], restrict: Set[Reportable] = Set(), engineForm: String) =
    Renderer(loggerDisplayProcessor, rootUrl, restrict, live).
      configureAttribute(Renderer.decisionTreeConfig(params, conclusion, None),
        Renderer.setAttribute(Renderer.engineFromTestsKey, "engineForm", engineForm),
        Renderer.setAttribute("Engine", "live", true)).
        configureNestedHolder[Reportable](reportTemplate, projectTemplate, liveEngineTemplate, liveEngineWithChildrenTemplate)

  def usecaseHtml(rootUrl: Option[String], test: Option[Test] = None, restrict: Set[Reportable] = Set()) =
    Renderer(loggerDisplayProcessor, rootUrl, restrict, live).
      configureAttribute(Renderer.decisionTreeConfig(None, None, test)).
      configureNestedHolder[Reportable](reportTemplate, projectTemplate, engineWithTestsTemplate, engineWithChildEngineTemplate, childEngineTemplate, useCaseTemplate).
      configureReportable(scenarioTemplate)

  def scenarioHtml(rootUrl: Option[String], conclusion: Conclusion, test: Test, restrict: Set[Reportable] = Set()) =
    Renderer(loggerDisplayProcessor, rootUrl, restrict, live).
      configureAttribute(Renderer.decisionTreeConfig(Some(test.params), Some(conclusion), Some(test))).
      configureNestedHolder[Reportable](reportTemplate, projectTemplate, engineWithTestsTemplate, engineWithChildEngineTemplate, childEngineTemplate, useCaseTemplate).
      configureReportable(scenarioTemplate)

  def documentsHtml(rootUrl: Option[String]) = Renderer(loggerDisplayProcessor, rootUrl, Set(), live).
    configureAttribute(Renderer.setMergedReportable).
    configureNestedHolder[Reportable](reportTemplate, mergedTemplate)

  def mergedReportableTitle(rootUrl: Option[String]) = Renderer(loggerDisplayProcessor, rootUrl, Set(), live).
    configureNestedHolder[Reportable](mergedTemplate, mergedTitleTemplate, mergedDescriptionTemplate,
      requirementAndEngineTemplate, useCaseIconTemplate).
      configureReportable(scenarioSummaryTemplate)

  def traceHtml(rootUrl: Option[String]) = Renderer(loggerDisplayProcessor, rootUrl, Set(), live, walker = new TraceItemWalker).
    configureAttribute(Renderer.traceItemConfig, Renderer.traceItemEngineConfig).
    configureNestedHolder[Reportable](reportTemplate, traceItemTemplate).
    configureReportable(traceItemEngineWithChildrenTemplate, traceItemEngineChildTemplate, traceItemEngineBuiltFromTestsTemplate)

}

trait DocumentPrinterStrategy {
  /** The report passed in probably holds engines. The report coming out holds the structure to be printed */
  def makeReportOfJustDocuments(report: NestedHolder[Reportable]): Reportable
}

class SimpleDocumentPrinterStrategy extends DocumentPrinterStrategy {
  def makeReportOfJustDocuments(report: NestedHolder[Reportable]) = SimpleRequirementAndHolder(report)
}

case class RequirementAndEngine(reportable: RequirementAndHolder, engine: Option[Engine]) extends RequirementAndHolder with ReportableWrapper {
  def title = reportable.title
  def description = reportable.description
  def priority = reportable.priority
  def children = reportable.children
  def references = reportable.references
  def delegate = Some(reportable)
  override def toString() = s"RequirementAndEngine(reportable=$reportable, engine=$engine)"
}

class ByReferenceDocumentPrinterStrategy(document: Option[Document], keyStrategy: KeyStrategy, debug: Boolean = false) extends DocumentPrinterStrategy {
  type ReportableToPath = Map[Reportable, List[Reportable]]
  type ReportableToKey = Map[Reportable, String]
  val documentMergeStrategy = document.collect { case (d) => d.mergeStrategy }.getOrElse(DocumentMergeStrategy.default)
  def findReportableToPathFor(r: NestedHolder[Reportable]) = r.foldWithPath[ReportableToPath](Map(), (acc, path) => acc + (path.head -> path))

  def findReferenceFor(document: Option[Document], r: Reportable) = r match {
    case r: Requirement => r.references.find((ref) => ref.document == document)
    case _ => None
  }

  def addToFor(document: Option[Document], reportableToPath: ReportableToPath, mapToKey: ReportableToKey, r: Reportable): ReportableToKey = {
    if (mapToKey.contains(r))
      mapToKey
    else
      findReferenceFor(document, r) match {
        case Some(ref) =>
          if (debug)
            println("raw " + ref.ref + "<--" + Reportable.templateNameAndTitle(r))
          mapToKey + (r -> ref.ref)
        case _ => {
          val result = reportableToPath(r) match {
            case me :: (parent: NestedHolder[Reportable]) :: tail =>
              val withParent = addToFor(document, reportableToPath, mapToKey, parent);
              withParent.get(parent) match {
                case Some(parentRef) => {
                  val myRef = keyStrategy.findKeyFor(parentRef, parent.children, me)
                  if (debug)
                    println("raw " + myRef + "<--" + Reportable.templateNameAndTitle(me))
                  withParent + (me -> myRef)
                }
                case _ => if (document.isDefined) withParent else withParent + (me -> keyStrategy.rootKey) // i.e. we are part of the document 'None'
              }
            case me :: Nil =>
              if (document.isDefined) mapToKey else mapToKey + (me -> keyStrategy.rootKey) // i.e. we are part of the document 'None'
            case _ => throw new IllegalStateException
          }
          result
        }
      }
  }

  def findReportableToRef(report: NestedHolder[Reportable], reportableToPath: ReportableToPath) = {
    val reportableToRef = report.foldLeft[ReportableToKey](Map())((acc, r) => addToFor(document, reportableToPath, acc, r))
    reportableToRef
  }

  def findStructuredMap(report: NestedHolder[Reportable]) = {
    val reportableToPath = findReportableToPathFor(report)
    val reportableToRef = findReportableToRef(report, reportableToPath)
    val structuredMap =
      report.foldLeft(StructuredMapOfList[RequirementAndEngine]())((acc, r) => {
        val path = reportableToPath(r)
        val ref = reportableToRef.get(r)
        val engine = PathUtils.findEnginePathIfExists(path)
        ref match {
          case Some(key) =>
            documentMergeStrategy.toRequirementAndEngine(r, engine) match {
              case Some(re) => acc + (key -> re)
              case _ => acc
            }
          case _ => acc
        }
      })
    structuredMap
  }

  def findMergedStructuredMap(from: StructuredMapOfList[RequirementAndEngine]) = {

    val modifiedMap = from.fold[StructuredMap[Reportable]](StructuredMap())((acc, key, list) =>
      acc + (key -> documentMergeStrategy.merge(key, list)))
    modifiedMap
  }

  def mergedMapToReportable(from: StructuredMap[Reportable], key: Key): NestedHolder[Reportable] = {
    val children = from.kidsOf(key).map(mergedMapToReportable(from, _))
    from(key.key) match {
      case m: MergedReportable => m.copy(children = children)
      case s: SimpleRequirementAndHolder => s.copy(children = children)
    }
  }

  def makeReportOfJustDocuments(report: NestedHolder[Reportable]) = {
    val structuredMap = findStructuredMap(report)
    val modifiedMap = findMergedStructuredMap(structuredMap)
    val result = mergedMapToReportable(modifiedMap, "")
    result
  }
}

object SimpleRequirementAndHolder {
  def withJustChildren(children: Reportable*) = new SimpleRequirementAndHolder(None, None, None, None, Set(), children.toList)
  def apply(r: Reportable): Requirement = r match {
    case r: SimpleRequirementAndHolder => r
    case rh: RequirementAndHolder => apply(rh, rh.children.map(apply(_)))
    case r: Requirement => r
    case _ => throw new IllegalStateException(r.getClass + "\n" + r);
  }

  def apply(r: RequirementAndHolder, replacementChildren: List[Reportable]): RequirementAndHolder =
    (r, replacementChildren) match {
      case (s: Test, List()) => s
      case _ => {
        val sortedChildren = replacementChildren.sortBy(Reportable.textOrder(_))
        new SimpleRequirementAndHolder(Some(r), r.title, r.description, r.priority, r.references, sortedChildren)
      }
    }

  def apply() = new SimpleRequirementAndHolder(None, None, None, None, Set(), List())
}

case class SimpleRequirementAndHolder(delegate: Option[Reportable], title: Option[String], description: Option[String], priority: Option[Int], references: Set[Reference], children: List[Reportable]) extends RequirementAndHolder with ReportableWrapper with ReportableWithTextOrder {
  def textOrder = delegate.map { _.textOrder }.getOrElse(0)
  protected def shortToString(r: Any): String = r match {
    case m: MergedShortDescription => Reportable.templateName(m) + "(" + m.name + ")"
    case r: SimpleRequirementAndHolder => Reportable.templateName(r) + "(" + Reportable.templateName(r.delegate.getOrElse(None)) + "/" + r.delegate.collect { case r: Requirement => r.titleString } + ", children=" + r.children.map(shortToString(_)).mkString(",") + ")"
    case t: Test => Reportable.templateName(r) + "(" + t.params.mkString(",") + ")"
    case r: RequirementAndHolder => Reportable.templateName(r) + "(" + r.titleString + ", children=" + r.children.map(shortToString(_)).mkString(",") + ")"
    case r: Requirement => Reportable.templateName(r) + "(" + r.titleString + ")"
  }
  override def toString = shortToString(this)
}

class DocumentPrinter(report: Report, strategy: DocumentPrinterStrategy = new SimpleDocumentPrinterStrategy) {
  val actualReport = strategy.makeReportOfJustDocuments(report)

}

trait MergedShortDescription {
  def name: String
}

/** A merged requirement is used to handle the fact that many reportables may implement a '2.1' of a document. */
case class MergedReportable(val key: String, val titles: List[MergedTitle], val children: List[Reportable]) extends NestedHolder[Reportable] with MergedShortDescription with ReportableWithTemplate {
  def name = key + "/" + titles.map(_.title.getOrElse("None") + ",children=" + children.map(Reportable.templateNameAndTitle(_)).mkString(","))
  override def toString = "Merged(" + name + ")"
  def templateName = "Merged"
}
case class MergedTitle(title: Option[String], children: List[MergedDescription]) extends NestedHolder[Reportable] with MergedShortDescription {
  def name = title.getOrElse("None")
}
case class MergedDescription(description: Option[String], children: List[Reportable]) extends NestedHolder[Reportable] with MergedShortDescription {
  def name = description.getOrElse("None")
  override def toString = s"MergedDescription($name, children=$children)"
}

